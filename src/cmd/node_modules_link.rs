use std::fs;

use clap::Parser;

use crate::config::Config;
use crate::platform::active::ActivePackage;
use crate::platform::link;
use crate::platform::origin::InstallOrigin;
use crate::platform::path_ext::PathExt;

#[derive(Debug, Parser, Clone)]
pub struct NodeModulesLinkCommand {
  /// Target version to install
  pub version: Option<String>,

  #[arg(short = 'o', long = "origin")]
  pub origin: Option<InstallOrigin>,
}

pub async fn node_modules_link(
  config: Config,
  mut cmd: NodeModulesLinkCommand,
) -> anyhow::Result<()> {
  // Try use .apvmrc if available
  if cmd.origin.is_none() && cmd.version.is_none() {
    let Some(apvm_rc) = config.apvm_rc.clone() else {
      return Err(anyhow::anyhow!("No version specified"));
    };

    cmd.version = apvm_rc.specifier;
    cmd.origin = Some(apvm_rc.origin);
  }

  // Use the default origin if only the version is specified
  if cmd.origin.is_none() && cmd.version.is_some() {
    cmd.origin = Some(InstallOrigin::default())
  }

  let Some(version) = &cmd.version else {
    return Err(anyhow::anyhow!("No version specified"));
  };

  let Some(origin) = &cmd.origin else {
    return Err(anyhow::anyhow!("No version specified"));
  };

  let package = ActivePackage::try_from_specifier(&config, version, origin)?;
  if !package.exists()? {
    return Err(anyhow::anyhow!("Version not installed"));
  }

  match package.origin {
    InstallOrigin::Super => link_super(package, config, cmd).await,
    InstallOrigin::Git => link_git(package, config, cmd).await,
    InstallOrigin::Local => link_git(package, config, cmd).await,
  }
}

async fn link_super(
  _package: ActivePackage,
  _config: Config,
  _cmd: NodeModulesLinkCommand,
) -> anyhow::Result<()> {
  todo!()
}

async fn link_git(
  package: ActivePackage,
  config: Config,
  _cmd: NodeModulesLinkCommand,
) -> anyhow::Result<()> {
  // known paths
  let node_modules = config.pwd.join("node_modules");
  let node_modules_bin = node_modules.join(".bin");
  let node_modules_bin_atlaspack = node_modules_bin.join("atlaspack");
  let node_modules_atlaspack = node_modules.join("@atlaspack");
  let package_packages = package.static_path_real.join("packages");
  let package_node_modules = package.static_path_real.join("node_modules");

  // Create node_modules if it doesn't exist
  if !fs::exists(&node_modules)? {
    fs::create_dir_all(&node_modules)?;
  }
  if !fs::exists(&node_modules_bin)? {
    fs::create_dir_all(&node_modules_bin)?;
  }

  // Create new node_modules/@atlaspack
  if fs::exists(&node_modules_atlaspack)? {
    fs::remove_dir_all(&node_modules_atlaspack)?
  }
  fs::create_dir_all(&node_modules_atlaspack)?;

  // Delete existing node_modules/.bin/atlaspack
  if fs::exists(&node_modules_bin_atlaspack)? {
    fs::remove_file(&node_modules_bin_atlaspack)?
  }

  for entry in fs::read_dir(package_packages)? {
    let entry = entry?;
    let entry_path = entry.path();

    if !fs::metadata(&entry_path)?.is_dir() {
      continue;
    }

    for entry in fs::read_dir(entry_path)? {
      let entry = entry?;
      let entry_path = entry.path();

      if !fs::metadata(&entry_path)?.is_dir() {
        continue;
      }

      let package_json_path = entry_path.join("package.json");
      if !fs::exists(&package_json_path)? {
        continue;
      }

      let package_json_str = fs::read_to_string(&package_json_path)?;
      let json::JsonValue::Object(package_json) = json::parse(&package_json_str)? else {
        continue;
      };
      let Some(package_name) = package_json.get("name") else {
        continue;
      };

      let package_name = match package_name {
        json::JsonValue::Short(package_name) => package_name.to_string(),
        json::JsonValue::String(package_name) => package_name.clone(),
        _ => continue,
      };

      if !package_name.starts_with("@atlaspack/") {
        continue;
      }

      let Some(package_name) = package_name.strip_prefix("@atlaspack/") else {
        continue;
      };

      link::soft_link(&entry_path, &node_modules_atlaspack.join(package_name))?;
    }
  }

  link::soft_link(
    &package_node_modules,
    &node_modules_atlaspack.join("node_modules"),
  )?;

  link::hard_link_or_copy(&config.exe_path, &node_modules_bin_atlaspack)?;

  println!("✅ {} ({})", package.name, package.origin);
  println!("    ➜ {}", config.pwd.try_to_string()?);
  Ok(())
}
