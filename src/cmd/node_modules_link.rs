use std::fs::Permissions;
use std::fs::{self};
use std::os::unix::fs::PermissionsExt;
use std::path::PathBuf;

use clap::Parser;

use crate::config::Config;
use crate::platform::active::ActivePackage;
use crate::platform::link;
use crate::platform::origin::InstallOrigin;
use crate::platform::path_ext::PathExt;

#[derive(Debug, Parser, Clone)]
pub struct NodeModulesLinkCommand {
  /// Target version to install
  pub version: Option<String>,

  /// Install if it's not available
  #[arg(short = 'i', long = "install")]
  pub install: bool,

  #[arg(short = 'o', long = "origin")]
  pub origin: Option<InstallOrigin>,
}

pub async fn node_modules_link(
  config: Config,
  mut cmd: NodeModulesLinkCommand,
) -> anyhow::Result<()> {
  // Try use .apvmrc if available
  if cmd.origin.is_none() && cmd.version.is_none() {
    let Some(apvm_rc) = config.apvm_rc.clone() else {
      return Err(anyhow::anyhow!("No version specified"));
    };

    cmd.version = apvm_rc.version;
    cmd.origin = Some(apvm_rc.origin);
  }

  // Use the default origin if only the version is specified
  if cmd.origin.is_none() && cmd.version.is_some() {
    cmd.origin = Some(InstallOrigin::default())
  }

  let Some(version) = &cmd.version else {
    return Err(anyhow::anyhow!("No version specified"));
  };

  let Some(origin) = &cmd.origin else {
    return Err(anyhow::anyhow!("No version specified"));
  };

  let package = ActivePackage::try_from_specifier(&config, version, origin)?;
  if !package.exists()? {
    return Err(anyhow::anyhow!("Version not installed"));
  }

  match package.origin {
    InstallOrigin::Npm => link_npm(config, cmd).await,
    InstallOrigin::Git => link_git(package, config, cmd).await,
    InstallOrigin::Local => link_git(package, config, cmd).await,
  }
}

async fn link_npm(
  // package: ActivePackage,
  config: Config,
  _cmd: NodeModulesLinkCommand,
) -> anyhow::Result<()> {
  let source =
    PathBuf::from("/home/dalsh/Development/atlassian-labs/atlaspack/packages/core/super");

  // known paths
  let node_modules = config.pwd.join("node_modules");
  let node_modules_bin = node_modules.join(".bin");
  let node_modules_temp = node_modules.join(".apvm");
  let node_modules_bin_atlaspack = node_modules_bin.join("atlaspack");
  let node_modules_atlaspack = node_modules.join("@atlaspack");
  let package_lib = source.clone(); //package.static_path_real.join("lib");
  let package_lib_static = package_lib.join("lib");

  // Create node_modules if it doesn't exist
  if !fs::exists(&node_modules)? {
    fs::create_dir_all(&node_modules)?;
  }
  if !fs::exists(&node_modules_bin)? {
    fs::create_dir_all(&node_modules_bin)?;
  }

  // Create new node_modules/@atlaspack
  if fs::exists(&node_modules_atlaspack)? {
    fs::remove_dir_all(&node_modules_atlaspack)?
  }
  fs::create_dir_all(&node_modules_atlaspack)?;

  // Delete existing node_modules/.bin/atlaspack
  if fs::exists(&node_modules_bin_atlaspack)? {
    fs::remove_file(&node_modules_bin_atlaspack)?;
  }

  // Delete existing node_modules/.apvm
  if fs::exists(&node_modules_temp)? {
    fs::remove_dir_all(&node_modules_temp)?;
  }

  link::soft_link(&package_lib, &node_modules_temp)?;

  for entry in fs::read_dir(&package_lib_static)? {
    let entry = entry?;
    let entry_path = entry.path();

    if fs::metadata(&entry_path)?.is_dir() {
      continue;
    }

    let file_stem = entry_path.try_file_stem()?;

    if file_stem.starts_with("vendor.") {
      continue;
    }

    let node_modules_atlaspack_pkg = node_modules_atlaspack.join(&file_stem);
    if fs::exists(&node_modules_atlaspack_pkg)? {
      fs::remove_dir_all(&node_modules_atlaspack_pkg)?;
    }

    fs::create_dir(&node_modules_atlaspack_pkg)?;
    fs::write(
      node_modules_atlaspack_pkg.join("package.json"),
      (json::object! {
        "name": format!("@atlaspack/{file_stem}"),
        "main": "./index.js"
      })
      .to_string(),
    )?;

    fs::write(
      node_modules_atlaspack_pkg.join("index.js"),
      format!("module.exports = require('.apvm/lib/{file_stem}.js')\n"),
    )?;
  }

  #[cfg(unix)]
  {
    fs::write(
      &node_modules_bin_atlaspack,
      "#!/usr/bin/env node\nrequire('@atlaspack/cli')\n",
    )?;
    fs::set_permissions(&node_modules_bin_atlaspack, Permissions::from_mode(0o777))?;
  }

  Ok(())
}

async fn link_git(
  package: ActivePackage,
  config: Config,
  _cmd: NodeModulesLinkCommand,
) -> anyhow::Result<()> {
  // known paths
  let node_modules = config.pwd.join("node_modules");
  let node_modules_bin = node_modules.join(".bin");
  let node_modules_bin_atlaspack = node_modules_bin.join("atlaspack");
  let node_modules_atlaspack = node_modules.join("@atlaspack");
  let package_packages = package.static_path_real.join("packages");
  let package_node_modules = package.static_path_real.join("node_modules");

  // Create node_modules if it doesn't exist
  if !fs::exists(&node_modules)? {
    fs::create_dir_all(&node_modules)?;
  }
  if !fs::exists(&node_modules_bin)? {
    fs::create_dir_all(&node_modules_bin)?;
  }

  // Create new node_modules/@atlaspack
  if fs::exists(&node_modules_atlaspack)? {
    fs::remove_dir_all(&node_modules_atlaspack)?
  }
  fs::create_dir_all(&node_modules_atlaspack)?;

  // Delete existing node_modules/.bin/atlaspack
  if fs::exists(&node_modules_bin_atlaspack)? {
    fs::remove_file(&node_modules_bin_atlaspack)?
  }

  for entry in fs::read_dir(package_packages)? {
    let entry = entry?;
    let entry_path = entry.path();

    if !fs::metadata(&entry_path)?.is_dir() {
      continue;
    }

    for entry in fs::read_dir(entry_path)? {
      let entry = entry?;
      let entry_path = entry.path();

      if !fs::metadata(&entry_path)?.is_dir() {
        continue;
      }

      let package_json_path = entry_path.join("package.json");
      if !fs::exists(&package_json_path)? {
        continue;
      }

      let package_json_str = fs::read_to_string(&package_json_path)?;
      let json::JsonValue::Object(package_json) = json::parse(&package_json_str)? else {
        continue;
      };
      let Some(package_name) = package_json.get("name") else {
        continue;
      };

      let package_name = match package_name {
        json::JsonValue::Short(package_name) => package_name.to_string(),
        json::JsonValue::String(package_name) => package_name.clone(),
        _ => continue,
      };

      if !package_name.starts_with("@atlaspack/") {
        continue;
      }

      let Some(package_name) = package_name.strip_prefix("@atlaspack/") else {
        continue;
      };

      link::soft_link(&entry_path, &node_modules_atlaspack.join(package_name))?;
    }
  }

  link::soft_link(
    &package_node_modules,
    &node_modules_atlaspack.join("node_modules"),
  )?;

  link::hard_link_or_copy(&config.exe_path, &node_modules_bin_atlaspack)?;

  println!("✅ {} ({})", package.name, package.origin);
  println!("    ➜ {}", config.pwd.try_to_string()?);
  Ok(())
}
